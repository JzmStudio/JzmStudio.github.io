<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>深渊对垒：终极数值版</title>
    <style>
        :root {
            --bg: #030305;
            --panel: #0d0d12;
            --accent: #c5a059;
            --hp: #a30000;
            --xp: #1e40af;
            --text: #d1d5db;
        }

        body {
            margin: 0; background: var(--bg); color: var(--text);
            font-family: 'Cinzel', serif; overflow: hidden;
            display: flex; flex-direction: column; align-items: center;
        }

        /* UI 布局 */
        #top-bar {
            width: 100%; max-width: 900px; padding: 20px;
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(to bottom, #111118, transparent);
        }

        .stat-item { display: flex; flex-direction: column; gap: 5px; min-width: 150px; }
        .bar-outer { width: 100%; height: 8px; background: #111; border: 1px solid #333; border-radius: 4px; overflow: hidden; }
        .bar-inner { height: 100%; transition: width 0.4s; }

        /* 战斗舞台 */
        #stage {
            width: 100%; max-width: 900px; height: 450px;
            position: relative; margin-top: 10px;
            background: radial-gradient(circle at 50% 50%, #1a1a25 0%, transparent 70%);
        }

        #enemy-row { position: absolute; top: 80px; width: 100%; display: flex; justify-content: center; gap: 25px; }
        #player-row { position: absolute; bottom: 80px; width: 100%; display: flex; justify-content: center; }

        .unit { position: relative; width: 70px; height: 70px; }
        .diamond-frame { 
            position: absolute; width: 100%; height: 100%; 
            border: 2px solid var(--accent); transform: rotate(45deg);
            background: var(--panel); box-shadow: 0 0 20px rgba(0,0,0,0.8);
            display: flex; align-items: center; justify-content: center;
        }
        .enemy .diamond-frame { border-color: #7f1d1d; }
        .unit-content { position: relative; z-index: 2; text-align: center; font-size: 12px; font-weight: bold; width: 100%; }

        /* 动画 */
        .bump-up { animation: bump-up-anim 0.4s ease-in-out; z-index: 50; }
        .bump-down { animation: bump-down-anim 0.4s ease-in-out; z-index: 50; }
        @keyframes bump-up-anim { 0% { transform: translateY(0); } 40% { transform: translateY(-120px); } 100% { transform: translateY(0); } }
        @keyframes bump-down-anim { 0% { transform: translateY(0); } 40% { transform: translateY(120px); } 100% { transform: translateY(0); } }

        /* 跳字系统 */
        .pop-text {
            position: absolute; pointer-events: none; font-weight: 900; z-index: 100;
            animation: pop-fade 1s forwards; white-space: nowrap;
        }
        @keyframes pop-fade {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            20% { transform: translateY(-20px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-60px) scale(1); opacity: 0; }
        }

        /* 天赋星图 */
        #tree-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.98); z-index: 1000;
        }
        #tree-canvas-wrap {
            position: relative; width: 1000px; height: 700px; margin: 20px auto;
            background: #050507; border: 1px solid #222; overflow: hidden;
        }
        .node {
            position: absolute; width: 36px; height: 36px; border-radius: 50%;
            background: #0a0a0a; border: 2px solid #333; cursor: pointer;
            transform: translate(-50%, -50%); z-index: 10; transition: 0.3s;
        }
        .node.active { border-color: var(--accent); box-shadow: 0 0 15px var(--accent); background: #221a00; }
        .node.reachable { border-color: #666; }
        .node.keystone { width: 50px; height: 50px; border-style: double; border-width: 4px; }
        
        #tooltip {
            position: fixed; display: none; padding: 12px; background: #111;
            border: 1px solid var(--accent); color: #eee; font-size: 13px;
            pointer-events: none; z-index: 2000; width: 220px;
        }

        .btn {
            padding: 12px 40px; background: #0d0d12; border: 1px solid var(--accent);
            color: var(--accent); cursor: pointer; font-size: 16px; font-weight: bold;
        }
        .btn:hover:not(:disabled) { background: var(--accent); color: #000; }
        .btn:disabled { opacity: 0.2; }
    </style>
</head>
<body>

    <div id="top-bar">
        <div class="stat-item">
            <span style="font-size:12px; color:#888;">WAVE <b id="wave-val" style="color:#eee">1</b></span>
            <span style="font-size:12px; color:#888;">LEVEL <b id="lvl-val" style="color:#eee">1</b></span>
        </div>
        <div class="stat-item">
            <div style="display:flex; justify-content:space-between; font-size:12px;">
                <span>HEALTH</span><span id="hp-val">150/150</span>
            </div>
            <div class="bar-outer"><div id="hp-fill" class="bar-inner" style="background:var(--hp); width:100%"></div></div>
        </div>
        <div class="stat-item">
            <div style="display:flex; justify-content:space-between; font-size:12px;">
                <span>EXPERIENCE</span><span id="xp-val">0/50</span>
            </div>
            <div class="bar-outer"><div id="xp-fill" class="bar-inner" style="background:var(--xp); width:0%"></div></div>
        </div>
    </div>

    <div id="stage">
        <div id="enemy-row"></div>
        <div id="player-row">
            <div id="player-unit" class="unit">
                <div class="diamond-frame"></div>
                <div class="unit-content">
                    <div style="color:var(--accent)">HERO</div>
                    <div id="p-atk-display" style="font-size:16px">15</div>
                </div>
            </div>
        </div>
    </div>

    <div id="controls" style="margin-top:20px; display:flex; gap:20px;">
        <button id="fight-btn" class="btn" onclick="game.startAutoBattle()">进入战斗</button>
        <button id="tree-btn" class="btn" onclick="ui.toggleTree(true)">天赋星图 (<span id="pts-val">0</span>)</button>
    </div>

    <div id="tree-overlay">
        <h2 style="text-align:center; color:var(--accent); margin:10px;">天赋觉醒 (剩余点数: <span id="pts-val-2">0</span>)</h2>
        <div id="tree-canvas-wrap">
            <svg id="tree-svg" style="position:absolute; width:100%; height:100%; pointer-events:none;"></svg>
            <div id="nodes-layer"></div>
        </div>
        <div style="text-align:center;"><button class="btn" onclick="ui.toggleTree(false)">返回战斗</button></div>
    </div>

    <div id="tooltip"></div>

    <script>
        // --- 核心逻辑 ---
        const game = {
            player: {
                hp: 150, maxHp: 150, atk: 15,
                lvl: 1, xp: 0, nextXp: 50, pts: 0,
                multi: 1, cleave: 0, lifesteal: 0, armor: 0,
                critChance: 0.05, critMult: 1.5, cull: 0, reflect: 0
            },
            enemies: [], wave: 1, isFighting: false,

            init() {
                this.spawnEnemies();
                ui.initTree();
                ui.update();
            },

            spawnEnemies() {
                this.enemies = [];
                const count = Math.min(Math.floor(this.wave / 3) + 1, 7);
                for (let i = 0; i < count; i++) {
                    this.enemies.push({
                        hp: 30 + (this.wave * 12),
                        maxHp: 30 + (this.wave * 12),
                        atk: 5 + (this.wave * 2)
                    });
                }
                ui.renderEnemies();
            },

            async startAutoBattle() {
                if (this.isFighting) return;
                this.isFighting = true;
                ui.setControlState(false);

                while (this.enemies.length > 0 && this.player.hp > 0) {
                    // 玩家回合
                    for (let i = 0; i < this.player.multi; i++) {
                        if (this.enemies.length === 0) break;
                        await this.duel(true);
                        this.checkCull();
                        this.enemies = this.enemies.filter(e => e.hp > 0);
                        ui.renderEnemies();
                        await this.sleep(200);
                    }
                    if (this.enemies.length === 0) break;

                    // 敌人回合
                    for (let j = 0; j < this.enemies.length; j++) {
                        await this.duel(false, j);
                        if (this.player.hp <= 0) break;
                        await this.sleep(150);
                    }
                    await this.sleep(400);
                }
                this.endBattle();
            },

            async duel(isPlayer, enemyIdx = 0) {
                const target = isPlayer ? this.enemies[0] : this.player;
                const attacker = isPlayer ? this.player : this.enemies[enemyIdx];
                
                // 动画触发
                const pEl = document.getElementById('player-unit');
                const eEls = document.querySelectorAll('.enemy');
                const activeEEl = eEls[enemyIdx];
                if (isPlayer) pEl.classList.add('bump-up');
                else if (activeEEl) activeEEl.classList.add('bump-down');

                await this.sleep(150);

                // 数值计算
                let dmg = attacker.atk;
                let isCrit = false;

                if (isPlayer) {
                    if (Math.random() < this.player.critChance) {
                        dmg *= this.player.critMult;
                        isCrit = true;
                    }
                    target.hp -= dmg;
                    this.createPop(activeEEl, Math.floor(dmg), isCrit ? '#ffcc00' : '#ff4444', isCrit);
                    
                    // 反震伤害
                    this.player.hp -= target.atk;
                    this.createPop(pEl, target.atk, '#770000');

                    // 吸血
                    if (this.player.lifesteal > 0) {
                        const heal = Math.floor(dmg * this.player.lifesteal);
                        this.player.hp = Math.min(this.player.maxHp, this.player.hp + heal);
                        if (heal > 0) this.createPop(pEl, `+${heal}`, '#44ff44');
                    }
                } else {
                    const finalDmg = Math.max(1, dmg - this.player.armor);
                    this.player.hp -= finalDmg;
                    this.createPop(pEl, finalDmg, '#ff4444');
                    
                    // 反伤
                    if (this.player.reflect > 0) {
                        attacker.hp -= this.player.reflect;
                        this.createPop(activeEEl, this.player.reflect, '#ffaa00');
                    }
                }

                ui.update();
                await this.sleep(250);
                pEl.classList.remove('bump-up');
                if (activeEEl) activeEEl.classList.remove('bump-down');
            },

            checkCull() {
                if (this.player.cull > 0 && this.enemies[0]) {
                    if (this.enemies[0].hp / this.enemies[0].maxHp < 0.15) {
                        this.enemies[0].hp = 0;
                        this.createPop(document.querySelectorAll('.enemy')[0], "斩杀!", "#ffffff");
                    }
                }
            },

            createPop(el, text, color, isCrit = false) {
                if (!el) return;
                const rect = el.getBoundingClientRect();
                const pop = document.createElement('div');
                pop.className = 'pop-text';
                pop.style.left = (rect.left + rect.width/2) + 'px';
                pop.style.top = (rect.top) + 'px';
                pop.style.color = color;
                pop.style.fontSize = isCrit ? '24px' : '18px';
                pop.innerText = text;
                document.body.appendChild(pop);
                setTimeout(() => pop.remove(), 1000);
            },

            endBattle() {
                this.isFighting = false;
                if (this.player.hp <= 0) {
                    alert(`战败！你止步于第 ${this.wave} 波`);
                    location.reload();
                } else {
                    this.gainXp(25 + this.wave * 15);
                    this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.maxHp * 0.4);
                    this.wave++;
                    this.spawnEnemies();
                    ui.setControlState(true);
                }
                ui.update();
            },

            gainXp(amt) {
                this.player.xp += amt;
                while (this.player.xp >= this.player.nextXp) {
                    this.player.xp -= this.player.nextXp;
                    this.player.lvl++;
                    this.player.pts++;
                    this.player.nextXp = Math.floor(this.player.nextXp * 1.4);
                }
            },
            sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
        };

        // --- 天赋星图数据 (PoE 风格扩张) ---
        const treeData = {
            nodes: [
                { id: 0, x: 500, y: 350, name: '起源', desc: '一切的开始', effect: () => {} },
                // 力量扇区 (右下 - 攻击与处决)
                { id: 1, x: 600, y: 400, name: '力量', desc: '攻击力 +10', effect: () => game.player.atk += 10 },
                { id: 2, x: 700, y: 450, name: '重击', desc: '攻击力 +20', effect: () => game.player.atk += 20 },
                { id: 3, x: 800, y: 500, name: '处决者', desc: '核心：生命低于15%的敌人直接死亡', effect: () => game.player.cull = 1, keystone: true },
                { id: 4, x: 700, y: 350, name: '风怒', desc: '攻击次数 +1', effect: () => game.player.multi += 1 },
                
                // 敏捷扇区 (右上 - 暴击与吸血)
                { id: 5, x: 600, y: 250, name: '敏锐', desc: '暴击率 +10%', effect: () => game.player.critChance += 0.1 },
                { id: 6, x: 700, y: 150, name: '致命一击', desc: '暴击伤害 +100%', effect: () => game.player.critMult += 1.0 },
                { id: 7, x: 600, y: 100, name: '贪婪', desc: '吸血 +15%', effect: () => game.player.lifesteal += 0.15 },
                { id: 8, x: 500, y: 150, name: '血池', desc: '核心：吸血效果翻倍，但不再战后回血', effect: () => { game.player.lifesteal *= 2; game.endBattle = function() { 
                    this.isFighting = false; if(this.player.hp <= 0) location.reload(); else { this.gainXp(50); this.wave++; this.spawnEnemies(); ui.setControlState(true); }
                }}, keystone: true },

                // 防御扇区 (左侧 - 生命与反伤)
                { id: 9, x: 400, y: 350, name: '体魄', desc: '最大生命 +100', effect: () => { game.player.maxHp += 100; game.player.hp += 100; } },
                { id: 10, x: 300, y: 450, name: '坚毅', desc: '最大生命 +200', effect: () => { game.player.maxHp += 200; game.player.hp += 200; } },
                { id: 11, x: 300, y: 250, name: '护甲', desc: '固定减伤 +8', effect: () => game.player.armor += 8 },
                { id: 12, x: 200, y: 350, name: '荆棘', desc: '反弹 15 点伤害', effect: () => game.player.reflect += 15 },
                { id: 13, x: 100, y: 350, name: '瓦尔之壳', desc: '核心：护甲翻倍，但攻击力降低30%', effect: () => { game.player.armor *= 2; game.player.atk *= 0.7; }, keystone: true }
            ],
            links: [
                [0,1], [1,2], [2,3], [1,4],
                [0,5], [5,6], [5,7], [7,8],
                [0,9], [9,10], [9,11], [10,12], [11,12], [12,13]
            ]
        };

        const ui = {
            activeNodes: [0],
            update() {
                document.getElementById('hp-val').innerText = `${Math.ceil(game.player.hp)}/${game.player.maxHp}`;
                document.getElementById('hp-fill').style.width = (game.player.hp / game.player.maxHp * 100) + '%';
                document.getElementById('xp-val').innerText = `${game.player.xp}/${game.player.nextXp}`;
                document.getElementById('xp-fill').style.width = (game.player.xp / game.player.nextXp * 100) + '%';
                document.getElementById('lvl-val').innerText = game.player.lvl;
                document.getElementById('wave-val').innerText = game.wave;
                document.getElementById('pts-val').innerText = game.player.pts;
                document.getElementById('pts-val-2').innerText = game.player.pts;
                document.getElementById('p-atk-display').innerText = Math.floor(game.player.atk);
                this.refreshTree();
            },
            renderEnemies() {
                const row = document.getElementById('enemy-row');
                row.innerHTML = '';
                game.enemies.forEach(en => {
                    const d = document.createElement('div');
                    d.className = 'unit enemy';
                    d.innerHTML = `<div class="diamond-frame"></div><div class="unit-content">HP:${Math.ceil(en.hp)}<br>ATK:${en.atk}</div>`;
                    row.appendChild(d);
                });
            },
            initTree() {
                const layer = document.getElementById('nodes-layer');
                const svg = document.getElementById('tree-svg');
                treeData.links.forEach(link => {
                    const n1 = treeData.nodes[link[0]], n2 = treeData.nodes[link[1]];
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", n1.x); line.setAttribute("y1", n1.y);
                    line.setAttribute("x2", n2.x); line.setAttribute("y2", n2.y);
                    line.setAttribute("stroke", "#222"); line.setAttribute("stroke-width", "2");
                    line.id = `l-${link[0]}-${link[1]}`;
                    svg.appendChild(line);
                });
                treeData.nodes.forEach(node => {
                    const div = document.createElement('div');
                    div.className = 'node' + (node.keystone ? ' keystone' : '');
                    div.id = `n-${node.id}`;
                    div.style.left = node.x + 'px'; div.style.top = node.y + 'px';
                    div.onmouseover = (e) => this.showTooltip(e, node);
                    div.onmouseout = () => this.hideTooltip();
                    div.onclick = () => this.buyTalent(node);
                    layer.appendChild(div);
                });
            },
            refreshTree() {
                treeData.nodes.forEach(node => {
                    const el = document.getElementById(`n-${node.id}`);
                    el.classList.remove('active', 'reachable');
                    if (this.activeNodes.includes(node.id)) el.classList.add('active');
                    else if (this.canReach(node.id)) el.classList.add('reachable');
                });
                treeData.links.forEach(link => {
                    const line = document.getElementById(`l-${link[0]}-${link[1]}`);
                    if (this.activeNodes.includes(link[0]) && this.activeNodes.includes(link[1])) {
                        line.setAttribute("stroke", "#c5a059"); line.setAttribute("stroke-width", "3");
                    }
                });
            },
            canReach(id) {
                return treeData.links.some(l => (l[0]===id && this.activeNodes.includes(l[1])) || (l[1]===id && this.activeNodes.includes(l[0])));
            },
            buyTalent(node) {
                if (game.player.pts > 0 && !this.activeNodes.includes(node.id) && this.canReach(node.id)) {
                    game.player.pts--; this.activeNodes.push(node.id);
                    node.effect(); this.update();
                }
            },
            showTooltip(e, node) {
                const tt = document.getElementById('tooltip');
                tt.style.display = 'block'; tt.style.left = (e.clientX + 15) + 'px'; tt.style.top = (e.clientY + 15) + 'px';
                tt.innerHTML = `<b style="color:${node.keystone?'#ffcc00':'#c5a059'}">${node.name}</b><br>${node.desc}`;
            },
            hideTooltip() { document.getElementById('tooltip').style.display = 'none'; },
            toggleTree(s) { document.getElementById('tree-overlay').style.display = s ? 'block' : 'none'; },
            setControlState(s) { document.getElementById('fight-btn').disabled = !s; document.getElementById('tree-btn').disabled = !s; }
        };

        game.init();
    </script>
</body>
</html>