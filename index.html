<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>深渊对垒：资深策划打磨版</title>
    <style>
        :root {
            --bg: #030305;
            --panel: #0d0d12;
            --accent: #c5a059; /* 古典金 */
            --hp: #a30000;
            --xp: #1e40af;
            --node-off: #2a2a2a;
            --node-on: #c5a059;
            --node-reachable: #4a4a4a;
            --text: #d1d5db;
        }

        body {
            margin: 0; background: var(--bg); color: var(--text);
            font-family: 'Cinzel', serif; overflow: hidden;
            display: flex; flex-direction: column; align-items: center;
        }

        /* 顶部状态栏 */
        #top-bar {
            width: 100%; max-width: 900px; padding: 20px;
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(to bottom, #111118, transparent);
            border-bottom: 1px solid #222;
        }

        .stat-item { display: flex; flex-direction: column; gap: 5px; min-width: 140px; }
        .bar-outer { width: 100%; height: 8px; background: #111; border: 1px solid #333; border-radius: 4px; overflow: hidden; }
        .bar-inner { height: 100%; transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1); }

        /* 战斗舞台 */
        #stage {
            width: 100%; max-width: 900px; height: 450px;
            position: relative; margin-top: 10px;
            background: 
                radial-gradient(circle at 50% 50%, #1a1a25 0%, transparent 70%),
                url('https://www.transparenttextures.com/patterns/dark-matter.png');
        }

        #enemy-row { position: absolute; top: 80px; width: 100%; display: flex; justify-content: center; gap: 25px; }
        #player-row { position: absolute; bottom: 80px; width: 100%; display: flex; justify-content: center; }

        .unit { position: relative; width: 70px; height: 70px; transition: transform 0.1s; }
        .diamond-frame { 
            position: absolute; width: 100%; height: 100%; 
            border: 2px solid var(--accent); transform: rotate(45deg);
            background: var(--panel); box-shadow: 0 0 20px rgba(0,0,0,0.8);
            display: flex; align-items: center; justify-content: center;
        }
        .enemy .diamond-frame { border-color: #7f1d1d; }
        
        .unit-content { 
            position: relative; z-index: 2; text-align: center; 
            font-size: 12px; font-weight: bold; width: 100%;
        }

        /* 炉石对撞动画 */
        .bump-up { animation: bump-up-anim 0.4s ease-in-out; z-index: 50; }
        .bump-down { animation: bump-down-anim 0.4s ease-in-out; z-index: 50; }

        @keyframes bump-up-anim {
            0% { transform: translateY(0); }
            40% { transform: translateY(-120px) scale(1.1); }
            100% { transform: translateY(0); }
        }
        @keyframes bump-down-anim {
            0% { transform: translateY(0); }
            40% { transform: translateY(120px) scale(1.1); }
            100% { transform: translateY(0); }
        }

        /* 天赋星图 */
        #tree-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.98); z-index: 1000;
        }

        #tree-canvas-wrap {
            position: relative; width: 900px; height: 650px; margin: 30px auto;
            background: #050507; border: 1px solid #222; overflow: hidden;
        }

        .node {
            position: absolute; width: 44px; height: 44px;
            border-radius: 50%; background: #0a0a0a; border: 2px solid var(--node-off);
            cursor: pointer; transform: translate(-50%, -50%);
            z-index: 10; transition: all 0.3s;
            display: flex; align-items: center; justify-content: center;
            font-size: 10px; color: #888;
        }
        .node.active { border-color: var(--node-on); box-shadow: 0 0 20px var(--node-on); color: var(--node-on); background: #1a150a; }
        .node.reachable { border-color: #555; color: #aaa; }
        .node:hover { transform: translate(-50%, -50%) scale(1.15); z-index: 20; }

        /* Tooltip 浮窗 */
        #tooltip {
            position: fixed; display: none; padding: 12px; background: #111;
            border: 1px solid var(--accent); color: #eee; font-size: 13px;
            pointer-events: none; z-index: 2000; width: 180px;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
        }
        #tooltip b { color: var(--accent); display: block; margin-bottom: 4px; }

        /* 控制台 */
        #controls { margin-top: 20px; display: flex; gap: 25px; }
        .btn {
            padding: 12px 40px; background: #0d0d12; border: 1px solid var(--accent);
            color: var(--accent); cursor: pointer; font-size: 16px; font-weight: bold;
            transition: 0.2s;
        }
        .btn:hover:not(:disabled) { background: var(--accent); color: #000; box-shadow: 0 0 15px var(--accent); }
        .btn:disabled { opacity: 0.2; cursor: not-allowed; }

        #log { color: #666; font-size: 14px; margin-top: 15px; font-style: italic; }
    </style>
</head>
<body>

    <div id="top-bar">
        <div class="stat-item">
            <span style="font-size:12px; color:#888;">WAVE <b id="wave-val" style="color:#eee">1</b></span>
            <span style="font-size:12px; color:#888;">LEVEL <b id="lvl-val" style="color:#eee">1</b></span>
        </div>
        <div class="stat-item">
            <div style="display:flex; justify-content:space-between; font-size:12px;">
                <span>HEALTH</span><span id="hp-val">150/150</span>
            </div>
            <div class="bar-outer"><div id="hp-fill" class="bar-inner" style="background:var(--hp); width:100%"></div></div>
        </div>
        <div class="stat-item">
            <div style="display:flex; justify-content:space-between; font-size:12px;">
                <span>EXPERIENCE</span><span id="xp-val">0/50</span>
            </div>
            <div class="bar-outer"><div id="xp-fill" class="bar-inner" style="background:var(--xp); width:0%"></div></div>
        </div>
    </div>

    <div id="stage">
        <div id="enemy-row"></div>
        <div id="player-row">
            <div id="player-unit" class="unit">
                <div class="diamond-frame"></div>
                <div class="unit-content">
                    <div style="color:var(--accent)">HERO</div>
                    <div id="p-atk-display" style="font-size:16px">15</div>
                </div>
            </div>
        </div>
    </div>

    <div id="log">等待指令...</div>

    <div id="controls">
        <button id="fight-btn" class="btn" onclick="game.startAutoBattle()">进入战斗</button>
        <button id="tree-btn" class="btn" onclick="ui.toggleTree(true)">天赋星图 (<span id="pts-val">0</span>)</button>
    </div>

    <div id="tree-overlay">
        <h2 style="text-align:center; color:var(--accent); letter-spacing:4px;">天赋觉醒</h2>
        <div id="tree-canvas-wrap">
            <svg id="tree-svg" style="position:absolute; width:100%; height:100%; pointer-events:none;"></svg>
            <div id="nodes-layer"></div>
        </div>
        <div style="text-align:center;">
            <button class="btn" onclick="ui.toggleTree(false)">返回深渊</button>
        </div>
    </div>

    <div id="tooltip"></div>

    <script>
        // --- 游戏逻辑核心 ---
        const game = {
            player: {
                hp: 150, maxHp: 150, atk: 15,
                lvl: 1, xp: 0, nextXp: 50, pts: 0,
                multi: 1, cleave: 0, lifesteal: 0, armor: 0
            },
            enemies: [],
            wave: 1,
            isFighting: false,

            init() {
                this.spawnEnemies();
                ui.initTree();
                ui.update();
            },

            spawnEnemies() {
                this.enemies = [];
                const count = Math.min(Math.floor(this.wave / 3) + 1, 7);
                for (let i = 0; i < count; i++) {
                    this.enemies.push({
                        hp: 25 + (this.wave * 10),
                        maxHp: 25 + (this.wave * 10),
                        atk: 4 + (this.wave * 2)
                    });
                }
                ui.renderEnemies();
            },

            async startAutoBattle() {
                if (this.isFighting) return;
                this.isFighting = true;
                ui.setControlState(false);

                while (this.enemies.length > 0 && this.player.hp > 0) {
                    // 玩家回合
                    for (let i = 0; i < this.player.multi; i++) {
                        if (this.enemies.length === 0) break;
                        await this.duel(true);
                        if (this.enemies.length === 0) break;
                        await this.sleep(200);
                    }

                    if (this.enemies.length === 0 || this.player.hp <= 0) break;

                    // 敌人回合
                    ui.log("敌方反击...");
                    for (let j = 0; j < this.enemies.length; j++) {
                        await this.duel(false, j);
                        if (this.player.hp <= 0) break;
                        await this.sleep(150);
                    }
                    await this.sleep(400);
                }

                this.endBattle();
            },

            async duel(isPlayerAttacking, enemyIdx = 0) {
                const target = isPlayerAttacking ? this.enemies[0] : this.player;
                const attacker = isPlayerAttacking ? this.player : this.enemies[enemyIdx];
                
                // 1. 触发对撞动画
                const playerEl = document.getElementById('player-unit');
                const enemyEls = document.querySelectorAll('.enemy');
                const activeEnemyEl = enemyEls[enemyIdx];

                if (isPlayerAttacking) playerEl.classList.add('bump-up');
                else if (activeEnemyEl) activeEnemyEl.classList.add('bump-down');

                await this.sleep(150); // 撞击瞬间

                // 2. 数值结算
                if (isPlayerAttacking) {
                    target.hp -= attacker.atk;
                    this.player.hp -= target.atk; // 反震
                    if (this.player.lifesteal > 0) {
                        this.player.hp = Math.min(this.player.maxHp, this.player.hp + (attacker.atk * this.player.lifesteal));
                    }
                    if (this.player.cleave > 0 && this.enemies[1]) {
                        this.enemies[1].hp -= attacker.atk * 0.4;
                    }
                } else {
                    const finalDmg = Math.max(1, attacker.atk - this.player.armor);
                    this.player.hp -= finalDmg;
                }

                ui.update();
                await this.sleep(250); // 回弹动画结束
                
                playerEl.classList.remove('bump-up');
                if (activeEnemyEl) activeEnemyEl.classList.remove('bump-down');

                this.enemies = this.enemies.filter(e => e.hp > 0);
                ui.renderEnemies();
            },

            endBattle() {
                this.isFighting = false;
                if (this.player.hp <= 0) {
                    alert(`战败！你止步于波次 ${this.wave}`);
                    location.reload();
                } else {
                    this.gainXp(25 + this.wave * 15);
                    this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.maxHp * 0.4);
                    this.wave++;
                    this.spawnEnemies();
                    ui.setControlState(true);
                    ui.log(`战斗胜利！生命值已大幅回复。`);
                }
                ui.update();
            },

            gainXp(amt) {
                this.player.xp += amt;
                while (this.player.xp >= this.player.nextXp) {
                    this.player.xp -= this.player.nextXp;
                    this.player.lvl++;
                    this.player.pts++;
                    this.player.nextXp = Math.floor(this.player.nextXp * 1.4);
                    ui.log("等级提升！获得天赋点。");
                }
            },

            sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
        };

        // --- 天赋树系统 ---
        const treeData = {
            nodes: [
                { id: 0, x: 450, y: 325, name: '魂之源', desc: '一切力量的起点', effect: () => {} },
                // 攻击系 (右)
                { id: 1, x: 550, y: 325, name: '磨砺', desc: '攻击力 +10', effect: () => game.player.atk += 10 },
                { id: 2, x: 650, y: 250, name: '狂暴', desc: '单回合攻击次数 +1', effect: () => game.player.multi += 1 },
                { id: 3, x: 650, y: 400, name: '横扫', desc: '攻击时对相邻敌人造成40%溅射伤害', effect: () => game.player.cleave = 1 },
                // 防御系 (左)
                { id: 4, x: 350, y: 325, name: '坚韧', desc: '最大生命值 +80', effect: () => { game.player.maxHp += 80; game.player.hp += 80; } },
                { id: 5, x: 250, y: 250, name: '重甲', desc: '固定减免受到的伤害 5 点', effect: () => game.player.armor += 5 },
                { id: 6, x: 250, y: 400, name: '贪婪', desc: '获得 20% 伤害吸血', effect: () => game.player.lifesteal += 0.2 },
            ],
            links: [[0,1], [1,2], [1,3], [0,4], [4,5], [4,6]]
        };

        const ui = {
            activeNodes: [0],

            update() {
                document.getElementById('hp-val').innerText = `${Math.ceil(game.player.hp)}/${game.player.maxHp}`;
                document.getElementById('hp-fill').style.width = (game.player.hp / game.player.maxHp * 100) + '%';
                document.getElementById('xp-val').innerText = `${game.player.xp}/${game.player.nextXp}`;
                document.getElementById('xp-fill').style.width = (game.player.xp / game.player.nextXp * 100) + '%';
                document.getElementById('lvl-val').innerText = game.player.lvl;
                document.getElementById('wave-val').innerText = game.wave;
                document.getElementById('pts-val').innerText = game.player.pts;
                document.getElementById('p-atk-display').innerText = game.player.atk;
                this.refreshTree();
            },

            renderEnemies() {
                const row = document.getElementById('enemy-row');
                row.innerHTML = '';
                game.enemies.forEach(en => {
                    const d = document.createElement('div');
                    d.className = 'unit enemy';
                    d.innerHTML = `<div class="diamond-frame"></div><div class="unit-content">HP:${Math.ceil(en.hp)}<br>ATK:${en.atk}</div>`;
                    row.appendChild(d);
                });
            },

            initTree() {
                const layer = document.getElementById('nodes-layer');
                const svg = document.getElementById('tree-svg');
                
                treeData.links.forEach(link => {
                    const n1 = treeData.nodes[link[0]], n2 = treeData.nodes[link[1]];
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", n1.x); line.setAttribute("y1", n1.y);
                    line.setAttribute("x2", n2.x); line.setAttribute("y2", n2.y);
                    line.setAttribute("stroke", "#222"); line.setAttribute("stroke-width", "3");
                    line.id = `l-${link[0]}-${link[1]}`;
                    svg.appendChild(line);
                });

                treeData.nodes.forEach(node => {
                    const div = document.createElement('div');
                    div.className = 'node';
                    div.id = `n-${node.id}`;
                    div.style.left = node.x + 'px'; div.style.top = node.y + 'px';
                    div.innerHTML = node.id === 0 ? 'START' : '';
                    
                    div.onmouseover = (e) => this.showTooltip(e, node);
                    div.onmouseout = () => this.hideTooltip();
                    div.onclick = () => this.buyTalent(node);
                    layer.appendChild(div);
                });
            },

            refreshTree() {
                treeData.nodes.forEach(node => {
                    const el = document.getElementById(`n-${node.id}`);
                    el.classList.remove('active', 'reachable');
                    if (this.activeNodes.includes(node.id)) el.classList.add('active');
                    else if (this.canReach(node.id)) el.classList.add('reachable');
                });
                treeData.links.forEach(link => {
                    const line = document.getElementById(`l-${link[0]}-${link[1]}`);
                    if (this.activeNodes.includes(link[0]) && this.activeNodes.includes(link[1])) {
                        line.setAttribute("stroke", "#c5a059");
                        line.setAttribute("stroke-width", "4");
                    }
                });
            },

            canReach(id) {
                return treeData.links.some(l => (l[0]===id && this.activeNodes.includes(l[1])) || (l[1]===id && this.activeNodes.includes(l[0])));
            },

            buyTalent(node) {
                if (game.player.pts > 0 && !this.activeNodes.includes(node.id) && this.canReach(node.id)) {
                    game.player.pts--;
                    this.activeNodes.push(node.id);
                    node.effect();
                    this.update();
                }
            },

            showTooltip(e, node) {
                const tt = document.getElementById('tooltip');
                tt.style.display = 'block';
                tt.style.left = (e.clientX + 15) + 'px';
                tt.style.top = (e.clientY + 15) + 'px';
                tt.innerHTML = `<b>${node.name}</b>${node.desc}`;
            },

            hideTooltip() { document.getElementById('tooltip').style.display = 'none'; },
            toggleTree(s) { document.getElementById('tree-overlay').style.display = s ? 'block' : 'none'; },
            setControlState(s) { document.getElementById('fight-btn').disabled = !s; document.getElementById('tree-btn').disabled = !s; },
            log(m) { document.getElementById('log').innerText = m; }
        };

        game.init();
    </script>
</body>
</html>